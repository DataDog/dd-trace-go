# Specula configuration for Phase 1: Span Lifecycle Model
#
# This config tells Specula how to translate the Go concurrency protocol
# in source/spanlifecycle/span_lifecycle.go into a TLA+ specification.

# Path to the Go source file to analyze
source_file: "../source/spanlifecycle/span_lifecycle.go"

# Output directory for generated TLA+ specs
output_dir: "../specs/span_lifecycle"

# Model constants — keep small to avoid state space explosion.
# 2 goroutines × 3 spans gives meaningful coverage of lock ordering
# and partial flush paths without exceeding practical TLC limits.
model:
  constants:
    NUM_GOROUTINES: 2
    NUM_SPANS: 3
    PARTIAL_FLUSH_MIN: 2
    TRACE_MAX_SIZE: 5

  # Initial variable state
  init:
    spans: "[] \\ empty sequence"
    finished_count: 0
    trace_full: false
    trace_locked: false

  # Actions that Specula should model as TLA+ next-state relations.
  # Each maps to a Go function in the source.
  actions:
    - name: "StartSpan"
      source: "push"
      description: "A goroutine creates a new span and pushes it into the trace buffer"

    - name: "SetOperationName"
      source: "SetOperationName"
      description: "A goroutine modifies a span's operation name (guarded by finish check)"

    - name: "FinishSpan"
      source: "finish"
      description: "A goroutine finishes a span (acquires span.mu then trace.mu)"

    - name: "PartialFlush"
      source: "finishedOneLocked"
      description: "Trace performs partial flush when threshold is met"

  # Invariant properties to check
  invariants:
    - name: "NoModificationAfterFinish"
      type: "safety"
      description: "A finished span's mutable fields never change"
      formula: |
        \A s \in Spans:
          s.finished => [](s.name = s.name')

    - name: "LockOrdering"
      type: "safety"
      description: "span.mu is always acquired before trace.mu (except partial flush inversion)"
      formula: |
        \A g \in Goroutines:
          holds(g, trace_mu) => ~holds(g, span_mu) \/ on_partial_flush_path(g)

    - name: "FinishIdempotent"
      type: "safety"
      description: "Calling finish twice leaves state unchanged after first call"
      formula: |
        \A s \in Spans:
          s.finished => finish(s) = UNCHANGED

    - name: "NoDeadlock"
      type: "liveness"
      description: "The system always makes progress (no circular lock waits)"
      formula: |
        []<>(\E g \in Goroutines: enabled(g))

    - name: "PartialFlushSafety"
      type: "safety"
      description: "Lock inversion in partial flush does not introduce deadlock"
      formula: |
        \A g \in Goroutines:
          on_partial_flush_path(g) =>
            ~holds(g, trace_mu) \/ ~holds(g, fSpan_mu)

# Specula pipeline options
pipeline:
  # Step 1: LLM-assisted Go → TLA+ translation
  step1:
    model: "claude-sonnet-4-20250514"
    max_tokens: 8192
    temperature: 0.1

  # Step 2: Control Flow Analysis
  step2:
    timeout_seconds: 120

  # Step 3: TLC model checking with automated fixes
  step3:
    max_fix_attempts: 5
    tlc_workers: 4
    tlc_depth: -1  # unbounded (BFS)

  # Step 4: Trace validation (optional)
  step4:
    enabled: false  # requires instrumented test harness
