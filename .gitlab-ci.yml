stages:
  - generate
  - benchmarks
  - macrobenchmarks
  - test-apps

variables:
  # This base image is created here: https://gitlab.ddbuild.io/DataDog/apm-reliability/benchmarking-platform/-/pipelines/56135449
  BASE_CI_IMAGE: 486234852809.dkr.ecr.us-east-1.amazonaws.com/ci/benchmarking-platform:dd-trace-go-56135449
  INDEX_FILE: index.txt
  KUBERNETES_SERVICE_ACCOUNT_OVERWRITE: dd-trace-go
  FF_USE_LEGACY_KUBERNETES_EXECUTION_STRATEGY: "true"
  BENCHMARK_TARGETS: "BenchmarkStartRequestSpan|BenchmarkHttpServeTrace|BenchmarkTracerAddSpans|BenchmarkStartSpan|BenchmarkSingleSpanRetention|BenchmarkOTelApiWithCustomTags|BenchmarkInjectW3C|BenchmarkExtractW3C|BenchmarkPartialFlushing|BenchmarkConfig|BenchmarkStartSpanConfig|BenchmarkGraphQL|BenchmarkSampleWAFContext|BenchmarkCaptureStackTrace|BenchmarkSetTagString|BenchmarkSetTagStringPtr|BenchmarkSetTagMetric|BenchmarkSetTagStringer|BenchmarkSerializeSpanLinksInMeta|BenchmarkLogs|BenchmarkParallelLogs|BenchmarkMetrics|BenchmarkParallelMetrics"

# In order to run benchmarks in parallel, we generate a matrix of test names based on the BENCHMARK_TARGETS variable.
# This will be used in tandem with bp-runner in benchmarks.yml.
# This will allow us to spin up a child job in GitLab CI that handles running all of the benchmarks in parallel.
generate_matrix:
  stage: generate
  image: $BASE_CI_IMAGE
  tags: ["runner:apm-k8s-tweaked-metal"]
  script:
    - |
      # 1. Include any relevant variables that the GitLab CI/CD pipelines might need.
      
      echo "---" > generated_benchmark_matrix.yml
      echo "include:" >> generated_benchmark_matrix.yml
      echo "  - project: '${CI_PROJECT_PATH}'" >> generated_benchmark_matrix.yml
      echo "    ref: '${CI_COMMIT_SHA}'" >> generated_benchmark_matrix.yml
      echo "    file: '.gitlab/benchmarks.yml'" >> generated_benchmark_matrix.yml
      echo "" >> generated_benchmark_matrix.yml

      # 2. Initialize the list of stages that need to be run.

      echo "stages:" >> generated_benchmark_matrix.yml
      echo "  - benchmark_matrix" >> generated_benchmark_matrix.yml
      echo "" >> generated_benchmark_matrix.yml

      # 3. Create the benchmark_matrix subjob.
      # This creates a "matrix" for the `.benchmark` job that exists inside .gitlab/benchmarks.yml.
      # The matrix tells GitLab how to split our benchmarks into multiple jobs. In this case, we are
      # using the `BENCHMARK_TARGETS` variable from above to give GitLab a list of test names.
      # We use these test names in our associated benchmarking-platform branch to run each benchmark 
      # on a different core.

      echo "benchmark_matrix:" >> generated_benchmark_matrix.yml
      echo "  extends: .benchmark" >> generated_benchmark_matrix.yml
      echo "  stage: benchmark_matrix" >> generated_benchmark_matrix.yml
      echo "  parallel:" >> generated_benchmark_matrix.yml
      echo "    matrix:" >> generated_benchmark_matrix.yml
      echo "      - BENCHMARK_NAME:" >> generated_benchmark_matrix.yml
      echo "$BENCHMARK_TARGETS" | tr '|' '\n' | while IFS= read -r benchmark_name; do
        printf "        - \"%s\"\n" "$benchmark_name" >> generated_benchmark_matrix.yml
      done
      echo "" >> generated_benchmark_matrix.yml
  artifacts:
    paths:
      - generated_benchmark_matrix.yml
    expire_in: 1 hour # Artifact is temporary, needed only for the current pipeline

trigger_child_pipeline:
  stage: benchmarks
  trigger:
    include:
      - artifact: generated_benchmark_matrix.yml
        job: generate_matrix
    strategy: depend
  needs:
    - generate_matrix

include:
  - local: ".gitlab/macrobenchmarks.yml"
  - local: ".gitlab/test-apps.yml"