name: AppSec Tests
on:
  workflow_call: # allows to reuse this workflow
    inputs:
      ref:
        description: 'The branch to run the workflow on'
        required: true
        type: string
  workflow_dispatch: # manually
  schedule: # nightly
    - cron: "0 0 * * *"
  pull_request: # on pull requests touching appsec files
    paths:
      - '.github/workflows/appsec.yml'
      - 'internal/appsec/**'
      - 'appsec/**'
      - 'contrib/**/appsec.go'
  merge_group: # on merge groups touching appsec files
    paths:
      - '.github/workflows/appsec.yml'
      - 'internal/appsec/**'
      - 'appsec/**'
      - 'contrib/**/appsec.go'
  push:
    branches: release-v*
env:
  DD_APPSEC_WAF_TIMEOUT: 1m
  TESTS: >
    ./appsec/...
    ./internal/appsec/...
    ./contrib/gin-gonic/gin/...
    ./contrib/google.golang.org/grpc/...
    ./contrib/net/http/...
    ./contrib/gorilla/mux/...
    ./contrib/go-chi/chi/...
    ./contrib/go-chi/chi.v5/...
    ./contrib/labstack/echo.v4/...
    ./contrib/99designs/gqlgen/...
    ./contrib/graphql-go/graphql/...
    ./contrib/graph-gophers/graphql-go/...
jobs:
  go-mod-caching:
    name: Prepare Go modules cache
    runs-on: ubuntu-latest-16-cores
    outputs:
      key: ${{ steps.cfg.outputs.key }}
      path: ${{ steps.cfg.outputs.path }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute cache configuration
        id: cfg
        run: |
          echo "key=go-pkg-mod-${{ hashFiles('**/go.sum') }}" >> $GITHUB_OUTPUT
          echo "path=${{ runner.temp }}/go/pkg/mod" >> $GITHUB_OUTPUT

      - uses: actions/setup-go@v5
        with:
          cache: false

      - name: Cache Go modules
        id: cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.cfg.outputs.path }}
          key: ${{ steps.cfg.outputs.key }}
          restore-keys: go-pkg-mod-
          enableCrossOsArchive: true
          lookup-only: true

      - name: Download Go modules
        if: steps.cache.outputs.cache-hit != 'true'
        env:
          GOMODCACHE: ${{ steps.cfg.outputs.path }}
        run: go mod download -x

#  native:
#    name: native ${{ toJSON(matrix) }}
#    runs-on: ${{ matrix.runs-on }}
#    env:
#      GOMODCACHE: ${{ needs.go-mod-caching.outputs.path }}
#    strategy:
#      matrix:
#        runs-on: [ macos-14, macos-13, macos-12, ubuntu-22.04, ubuntu-20.04 ]
#        go-version: [ "1.21", "1.20", "1.19" ]
#        cgo_enabled: [ "0", "1" ] # test it compiles with and without cgo
#        appsec_enabled: # test it compiles with and without appsec enabled
#          - DD_APPSEC_ENABLED=true
#          - DD_APPSEC_ENABLED=false
#          - "" # the env var is not defined so that the remote-config path can be taken
#        include:
#          - cgocheck:
#              GODEBUG=cgocheck=2
#          - go-version: "1.21"
#            cgocheck:  # 1.21 deprecates the GODEBUG=cgocheck=2 value, replacing it with GOEXPERIMENT=cgocheck2
#              GOEXPERIMENT=cgocheck2
#      fail-fast: false
#    steps:
#      - uses: actions/checkout@v4
#        with:
#          ref: ${{ inputs.ref || github.ref }}
#      - uses: actions/setup-go@v5
#        with:
#          go-version: ${{ matrix.go-version }}
#
#      - name: go test
#        shell: bash
#        run: |
#          go install gotest.tools/gotestsum@latest
#          # Run the tests with gotestsum
#          env ${{ matrix.cgocheck }} CGO_ENABLED=${{ matrix.cgo_enabled }} ${{ matrix.appsec_enabled }} ./.github/workflows/apps/appsec-test-contrib-submodules.sh

  # Tests cases were appsec end up being disabled at compilation time
  disabled:
    strategy:
      fail-fast: false
      matrix:
        go-args:
          - "-tags datadog.no_waf"
        runs-on: [ macos-13, ubuntu-latest-16-cores ]
        appsec_enabled:
          - DD_APPSEC_ENABLED=true
          - "" # the env var is not defined so that the remote-config path can be taken
        include:
          # Windows is not supported for now
          - runs-on: windows-latest
            go-args: ""
    name: disabled ${{ toJSON(matrix) }}
    runs-on: ${{ matrix.runs-on }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: stable

      - name: go test
        shell: bash
        run: |
          env ${{ matrix.appsec_enabled }} go test -v ${{ matrix.go-args }} $TESTS

  # Same tests but on the official golang container for linux
  golang-linux-container:
    name: golang-containers ${{ toJSON(matrix) }}
    runs-on: ubuntu-latest-16-cores
    needs: go-mod-caching
    env:
      GOMODCACHE: ${{ needs.go-mod-caching.outputs.path }}
    strategy:
      matrix:
        go-version: [ "1.21", "1.20", "1.19" ]
        distribution: [ bookworm, bullseye, buster, alpine ]
        cgo_enabled: # test it compiles with and without cgo
          - 0
          - 1
        appsec_enabled: # test it compiles with and without appsec enabled
          - -eDD_APPSEC_ENABLED=true
          - -eDD_APPSEC_ENABLED=false
          - "" # the env var is not defined so that the remote-config path can be taken
        exclude:
          - go-version: "1.21"
            distribution: buster

      fail-fast: false
    steps:
      - name: Restore Go modules cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ needs.go-mod-caching.outputs.path }}
          key: ${{ needs.go-mod-caching.outputs.key }}
          restore-keys: go-pkg-mod-
          enableCrossOsArchive: true
          fail-on-cache-miss: true

      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: go test
        env:
          CGO_ENABLED: ${{ matrix.cgo_enabled }}
        run: |
          cat <<EOF | docker run -i --platform=linux/arm64 -v "$PWD:$PWD" -w "$PWD" -v "$GOMODCACHE:$GOMODCACHE" \
            -eGOMODCACHE -eCGO_ENABLED -eDD_APPSEC_WAF_TIMEOUT ${{ matrix.appsec_enabled }} \
            golang:${{ matrix.go-version }}-${{ matrix.distribution }}
              set -ex
              go env
              go test -v $TESTS
          EOF

  linux-arm64:
    name: linux/arm64 ${{ toJSON(matrix) }}
    runs-on: ubuntu-latest-16-cores
    needs: go-mod-caching
    env:
      GOMODCACHE: ${{ needs.go-mod-caching.outputs.path }}
    strategy:
      matrix:
        cgo_enabled: # test it compiles with and without cgo
          - 0
          - 1
      fail-fast: false
    steps:
      - name: Restore Go modules cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ needs.go-mod-caching.outputs.path }}
          key: ${{ needs.go-mod-caching.outputs.key }}
          restore-keys: go-pkg-mod-
          enableCrossOsArchive: true
          fail-on-cache-miss: true

      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: go test
        env:
            DD_APPSEC_ENABLED: true
            CGO_ENABLED: ${{ matrix.cgo_enabled }}
        run: |
          cat <<EOF | docker run -i --platform=linux/arm64 -v "$PWD:$PWD" -w "$PWD" -v "$GOMODCACHE:$GOMODCACHE" \
            -eGOMODCACHE -eCGO_ENABLED -eDD_APPSEC_ENABLED -eDD_APPSEC_WAF_TIMEOUT golang
              set -ex
              go env
              go test -v $TESTS
          EOF
#
#  test-app:
#    uses: DataDog/appsec-go-test-app/.github/workflows/smoke-tests.yml@main
#    with:
#      dd-trace-go-version: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}
