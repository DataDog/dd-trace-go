// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

// gencontribs generates the list of third-party libraries from all contrib module dependencies.
// It traverses all contrib subdirectories and runs 'go list -m all' in each to capture all dependencies.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const generatedFileTemplate = `// Code generated by gencontribs. DO NOT EDIT.
// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

package stacktrace

// Code generated by github.com/DataDog/dd-trace-go/scripts/gencontribs DO NOT EDIT.

// generatedThirdPartyLibraries returns the list of third-party libraries
// automatically extracted from all contrib module dependencies.
//
// This list is generated at build time by traversing all contrib directories
// and running 'go list -m all' in each to capture all dependencies.
func generatedThirdPartyLibraries() []string {
	return []string{
{{- range .Libraries}}
		"{{.}}",
{{- end}}
	}
}
`

type templateData struct {
	Libraries []string
}

func main() {
	if len(os.Args) != 3 {
		log.Fatal("Usage: gencontribs <project-root> <output-file>")
	}

	projectRoot := os.Args[1]
	outputFile := os.Args[2]

	// Extract all third-party libraries using go list
	libraries, err := extractAllThirdPartyLibraries(projectRoot)
	if err != nil {
		log.Fatalf("Failed to extract third-party libraries: %v", err)
	}

	// Generate the Go source file
	if err := generateSourceFile(outputFile, libraries); err != nil {
		log.Fatalf("Failed to generate source file: %v", err)
	}

	log.Printf("Generated %s with %d third-party libraries", outputFile, len(libraries))
}

func extractAllThirdPartyLibraries(projectRoot string) ([]string, error) {
	contribDir := filepath.Join(projectRoot, "contrib")

	// Find all contrib subdirectories that contain go.mod files
	contribModules, err := findContribModules(contribDir)
	if err != nil {
		return nil, fmt.Errorf("failed to find contrib modules: %w", err)
	}

	seen := make(map[string]bool)

	// Process each contrib module
	for _, moduleDir := range contribModules {
		libraries, err := extractFromModule(moduleDir)
		if err != nil {
			log.Printf("Warning: failed to extract from %s: %v", moduleDir, err)
			continue
		}

		// Add to our set of libraries
		for _, lib := range libraries {
			seen[lib] = true
		}
	}

	// Convert set to sorted slice
	var result []string
	for lib := range seen {
		result = append(result, lib)
	}
	sort.Strings(result)

	return result, nil
}

func findContribModules(contribDir string) ([]string, error) {
	var modules []string

	err := filepath.Walk(contribDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.Name() == "go.mod" {
			modules = append(modules, filepath.Dir(path))
		}

		return nil
	})

	return modules, err
}

func extractFromModule(moduleDir string) ([]string, error) {
	cmd := exec.Command("go", "list", "-m", "-f", "{{.Path}}", "all")
	cmd.Dir = moduleDir
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run go list in %s: %w", moduleDir, err)
	}

	var libraries []string

	for _, line := range strings.Split(string(output), "\n") {
		path := strings.TrimSpace(line)
		if path == "" {
			continue
		}

		// Skip DataDog internal dependencies
		if strings.HasPrefix(path, "github.com/DataDog/") {
			continue
		}

		// Skip golang.org packages
		if strings.HasPrefix(path, "golang.org/") {
			continue
		}

		libraries = append(libraries, path)
	}

	return libraries, nil
}

func generateSourceFile(outputFile string, libraries []string) error {
	tmpl, err := template.New("generated").Parse(generatedFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := templateData{
		Libraries: libraries,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated Go code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write to output file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}
