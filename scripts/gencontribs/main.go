// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

// gencontribs generates the list of third-party libraries from contrib/ directory structure.
// It scans all contrib/*/go.mod files and extracts the main third-party dependencies.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/mod/modfile"
)

const generatedFileTemplate = `// Code generated by gencontribs. DO NOT EDIT.
// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

package stacktrace

// generatedThirdPartyLibraries returns the list of third-party libraries 
// automatically extracted from contrib/ directory go.mod files.
//
// This list is generated at build time by scanning all contrib/*/go.mod files
// and extracting all their third-party dependencies to maximize coverage.
func generatedThirdPartyLibraries() []string {
	return []string{
{{- range .Libraries}}
		"{{.}}",
{{- end}}
	}
}
`

type templateData struct {
	Libraries []string
}

func main() {
	if len(os.Args) != 2 {
		log.Fatal("Usage: gencontribs <output-file>")
	}

	outputFile := os.Args[1]

	// Find project root
	projectRoot, err := findProjectRoot()
	if err != nil {
		log.Fatalf("Failed to find project root: %v", err)
	}

	contribDir := filepath.Join(projectRoot, "contrib")
	if _, err := os.Stat(contribDir); os.IsNotExist(err) {
		log.Fatalf("contrib directory not found: %s", contribDir)
	}

	// Extract all third-party libraries from contrib modules
	libraries, err := extractAllThirdPartyLibraries(contribDir)
	if err != nil {
		log.Fatalf("Failed to extract third-party libraries: %v", err)
	}

	// Generate the Go source file
	if err := generateSourceFile(outputFile, libraries); err != nil {
		log.Fatalf("Failed to generate source file: %v", err)
	}

	log.Printf("Generated %s with %d third-party libraries", outputFile, len(libraries))
}

func findProjectRoot() (string, error) {
	// Start from current directory and walk up
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		// Look for go.work file (workspace root)
		if _, err := os.Stat(filepath.Join(dir, "go.work")); err == nil {
			return dir, nil
		}

		// Check if we're in the main dd-trace-go directory
		if _, err := os.Stat(filepath.Join(dir, "contrib")); err == nil {
			if _, err := os.Stat(filepath.Join(dir, "internal", "stacktrace")); err == nil {
				return dir, nil
			}
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break // Reached filesystem root
		}
		dir = parent
	}

	return "", fmt.Errorf("project root not found")
}

func extractAllThirdPartyLibraries(contribDir string) ([]string, error) {
	goModFiles, err := scanContribGoMods(contribDir)
	if err != nil {
		return nil, fmt.Errorf("failed to scan contrib go.mod files: %w", err)
	}

	if len(goModFiles) == 0 {
		return nil, fmt.Errorf("no go.mod files found in contrib directory")
	}

	var allLibraries []string
	seen := make(map[string]bool)

	for _, goModPath := range goModFiles {
		content, err := os.ReadFile(goModPath)
		if err != nil {
			log.Printf("Warning: could not read %s: %v", goModPath, err)
			continue
		}

		libs, err := extractThirdPartyLibraries(string(content))
		if err != nil {
			log.Printf("Warning: could not parse %s: %v", goModPath, err)
			continue
		}

		for _, lib := range libs {
			if !seen[lib] {
				seen[lib] = true
				allLibraries = append(allLibraries, lib)
			}
		}
	}

	sort.Strings(allLibraries)
	return allLibraries, nil
}

func scanContribGoMods(contribDir string) ([]string, error) {
	var goModFiles []string

	err := filepath.Walk(contribDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.Name() == "go.mod" {
			goModFiles = append(goModFiles, path)
		}

		return nil
	})

	return goModFiles, err
}

func extractThirdPartyLibraries(goModContent string) ([]string, error) {
	modFile, err := modfile.Parse("go.mod", []byte(goModContent), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to parse go.mod: %w", err)
	}

	var thirdPartyLibs []string

	for _, req := range modFile.Require {
		path := req.Mod.Path

		// Skip DataDog internal dependencies
		if strings.HasPrefix(path, "github.com/DataDog/") {
			continue
		}

		// Skip common testing and tooling dependencies
		if strings.HasPrefix(path, "github.com/stretchr/testify") {
			continue
		}
		if strings.HasPrefix(path, "golang.org/") {
			continue
		}

		// Include all other third-party libraries to maximize coverage
		thirdPartyLibs = append(thirdPartyLibs, path)
	}

	return thirdPartyLibs, nil
}

func generateSourceFile(outputFile string, libraries []string) error {
	tmpl, err := template.New("generated").Parse(generatedFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := templateData{
		Libraries: libraries,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated Go code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write to output file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}
