// Package addmsgpcomments adds annotations to methods generated by the msgp tool.
// It traverses the provided Go source files, identifies target methods like
// DecodeMsg, EncodeMsg, and Msgsize, and adds specified annotations as comments.
package main

import (
	"flag"
	"fmt"
	"go/token"
	"log/slog"
	"os"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/dstutil"
)

var (
	logger *slog.Logger

	// Annotations to add to each method.
	commentsToAdd = []string{
		"// +checklocksignore",
	}

	// Methods to target for annotations.
	targetMethods = map[string]bool{
		"DecodeMsg": true,
		"EncodeMsg": true,
		"Msgsize":   true,
	}
)

func processFile(filePath string) (bool, error) {
	logger.Debug("Processing file", "path", filePath)

	// Parse the file with the decorator, which preserves all formatting and comments.
	fset := token.NewFileSet()
	dec := decorator.NewDecorator(fset)

	content, err := os.ReadFile(filePath)
	if err != nil {
		return false, fmt.Errorf("failed to read file %s: %v", filePath, err)
	}

	f, err := dec.Parse(string(content))
	if err != nil {
		return false, fmt.Errorf("failed to parse file %s: %v", filePath, err)
	}

	// Track whether any changes were made.
	modified := false

	// Use dstutil.Apply to find and modify nodes
	result := dstutil.Apply(f, func(cursor *dstutil.Cursor) bool {
		// We only care about function declarations.
		funcDecl, ok := cursor.Node().(*dst.FuncDecl)
		if !ok {
			return true
		}

		// Check if this is a method we're interested in.
		if !targetMethods[funcDecl.Name.Name] {
			return true
		}

		logger.Debug("Found target method", "name", funcDecl.Name.Name)

		// Check if our comments already exist in the decorations.
		decs := funcDecl.Decs

		// Track which comments need to be added.
		commentsToAddMap := make(map[string]bool)
		for _, comment := range commentsToAdd {
			commentsToAddMap[comment] = true
		}

		// Remove comments that already exist.
		for _, existingComment := range decs.Start {
			delete(commentsToAddMap, existingComment)
		}

		// If there are no comments left to add, we're done with this node.
		if len(commentsToAddMap) == 0 {
			logger.Debug("All comments already exist", "method", funcDecl.Name.Name)
			return true
		}

		// Add the remaining comments.
		for comment := range commentsToAddMap {
			decs.Start = append(decs.Start, comment)
			logger.Debug("Added comment", "comment", comment, "method", funcDecl.Name.Name)
			modified = true
		}

		funcDecl.Decs = decs
		return true
	}, nil)

	if !modified {
		logger.Debug("No changes needed", "file", filePath)
		return false, nil
	}

	// Create a restorer and convert back to source code.
	res := decorator.NewRestorer()
	var buf strings.Builder
	if err := res.Fprint(&buf, result.(*dst.File)); err != nil {
		return false, fmt.Errorf("failed to restore file: %v", err)
	}
	output := buf.String()

	// Write the file back.
	logger.Debug("Writing changes", "file", filePath)
	err = os.WriteFile(filePath, []byte(output), 0644)
	if err != nil {
		return false, fmt.Errorf("failed to write to file %s: %v", filePath, err)
	}

	logger.Info("Successfully added comments", "file", filePath)
	return true, nil
}

func main() {
	// Parse command line flags
	debugFlag := flag.Bool("debug", false, "Enable debug logging")
	verboseFlag := flag.Bool("v", false, "Enable verbose mode (same as debug)")
	flag.Parse()

	logLevel := slog.LevelInfo
	if *debugFlag || *verboseFlag {
		logLevel = slog.LevelDebug
	}

	handler := slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: logLevel,
	})

	logger = slog.New(handler)
	slog.SetDefault(logger)

	if *debugFlag || *verboseFlag {
		logger.Debug("Debug logging enabled")
	}

	args := flag.Args()
	if len(args) == 0 {
		logger.Error("No files specified")
		fmt.Fprintf(os.Stderr, "Usage: %s [options] file1.go [file2.go...]\n", os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}

	successCount := 0
	for _, filePath := range args {
		modified, err := processFile(filePath)
		if err != nil {
			logger.Error("Processing failed", "error", err, "file", filePath)
			continue
		}
		if modified {
			successCount++
		}
	}

	if successCount > 0 {
		logger.Info("Processing completed", "files_modified", successCount)
		os.Exit(0)
	}
	logger.Info("No changes were made")
}
