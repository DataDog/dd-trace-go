// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2025 Datadog, Inc.

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/DataDog/dd-trace-go/v2/internal/env"
	"github.com/dave/jennifer/jen"
)

func main() {
	var (
		input  string
		output string
	)
	flag.StringVar(&input, "input", "./internal/env/supported-configurations.json", "Path to the input file")
	flag.StringVar(&output, "output", "./internal/env", "Path to the output directory")
	flag.Parse()

	var err error
	command := flag.Arg(0)
	switch command {
	case "generate":
		err = generate(input, output)
	case "check":
		err = check(input)
	default:
		err = fmt.Errorf("unknown command: %s", command)
	}

	if err != nil {
		slog.Error("error executing command", "error", err)
		os.Exit(1)
	}
	slog.Info("success executing command", "command", command)
}

type supportedConfiguration struct {
	SupportedConfigurations map[string][]string `json:"supportedConfigurations"`
	Aliases                 map[string][]string `json:"aliases"`
}

func generate(input, output string) error {
	keys, err := getSupportedConfigurationsKeys(input)
	if err != nil {
		return fmt.Errorf("error getting supported configuration keys: %w", err)
	}

	slog.Info("supported configuration keys count", "count", len(keys))

	f := jen.NewFilePath(output)
	f.HeaderComment("Unless explicitly stated otherwise all files in this repository are licensed")
	f.HeaderComment("under the Apache License Version 2.0.")
	f.HeaderComment("This product includes software developed at Datadog (https://www.datadoghq.com/).")
	f.HeaderComment("Copyright 2025 Datadog, Inc.")
	f.Comment("Code generated by github.com/DataDog/dd-trace-go/v2/scripts/configinverter. DO NOT EDIT.")
	f.Line()
	f.Comment("SupportedConfigurations is a map of supported configuration keys.")
	f.Var().Id("SupportedConfigurations").Op("=").Map(jen.String()).Struct().ValuesFunc(func(g *jen.Group) {
		for _, v := range keys {
			g.Add(jen.Line(), jen.Lit(v), jen.Op(":"), jen.Values())
		}
		g.Line()
	})

	if err := f.Save(output + "/supported_configurations.gen.go"); err != nil {
		return fmt.Errorf("error saving file: %w", err)
	}

	return nil
}

func getSupportedConfigurationsKeys(input string) ([]string, error) {
	fcontent, err := os.ReadFile(input)
	if err != nil {
		return nil, fmt.Errorf("error getting supported configuration keys from embed: %w", err)
	}

	slog.Info("read file", "file", input)

	var cfg supportedConfiguration
	if err := json.Unmarshal(fcontent, &cfg); err != nil {
		return nil, fmt.Errorf("error unmarshalling supported configuration: %w", err)
	}

	mapVar := []string{}
	for k := range cfg.SupportedConfigurations {
		mapVar = append(mapVar, k)
	}
	sort.Strings(mapVar)

	return mapVar, nil
}

func check(input string) error {
	keys, err := getSupportedConfigurationsKeys(input)
	if err != nil {
		return fmt.Errorf("error getting supported configuration keys: %w", err)
	}

	slog.Info("supported configuration keys in file", "count", len(keys))

	if len(env.SupportedConfigurations) != len(keys) {
		slog.Error("supported configuration keys count mismatch", "map_count", len(env.SupportedConfigurations),
			"file_count", len(keys))
		return fmt.Errorf("supported configuration keys count mismatch")
	}

	missingKeys := []string{}
	for _, k := range keys {
		if _, ok := env.SupportedConfigurations[k]; !ok {
			slog.Error("supported configuration key not found in map", "key", k)
			missingKeys = append(missingKeys, k)
		}
	}

	if len(missingKeys) > 0 {
		slog.Error("supported configuration keys missing in map", "count", len(missingKeys), "keys", missingKeys)
		return fmt.Errorf("supported configuration keys missing in map")
	}

	return nil
}
