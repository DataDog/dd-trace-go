// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

package http

import (
	"net/http"
	"net/http/httptest"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"testing"

	"github.com/DataDog/dd-trace-go/v2/ddtrace/ext"
	"github.com/DataDog/dd-trace-go/v2/ddtrace/mocktracer"
	"github.com/DataDog/dd-trace-go/v2/instrumentation/httptrace"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCodeOriginForSpansReflection(t *testing.T) {
	_, filename, _, ok := runtime.Caller(0)
	require.True(t, ok)
	thisFile, err := filepath.Abs(filename)
	require.NoError(t, err)
	testHandlersFile := filepath.Join(filepath.Dir(thisFile), "code_origin_handlers_test.go")
	muxFile, muxLine := serveMuxFileLine(t)

	wantFuncHandlerTags := map[string]any{
		"_dd.code_origin.type":            "entry",
		"_dd.code_origin.frames.0.file":   testHandlersFile,
		"_dd.code_origin.frames.0.line":   "13",
		"_dd.code_origin.frames.0.method": "github.com/DataDog/dd-trace-go/contrib/net/http/v2.testHandler",
	}
	wantTypeHandlerTags := map[string]any{
		"_dd.code_origin.type":            "entry",
		"_dd.code_origin.frames.0.file":   testHandlersFile,
		"_dd.code_origin.frames.0.line":   "20",
		"_dd.code_origin.frames.0.type":   "github.com/DataDog/dd-trace-go/contrib/net/http/v2.*CustomHandler",
		"_dd.code_origin.frames.0.method": "ServeHTTP",
	}
	wantStdlibMuxTags := map[string]any{
		"_dd.code_origin.type":            "entry",
		"_dd.code_origin.frames.0.file":   muxFile,
		"_dd.code_origin.frames.0.line":   muxLine,
		"_dd.code_origin.frames.0.type":   "net/http.*ServeMux",
		"_dd.code_origin.frames.0.method": "ServeHTTP",
	}
	wantInlineHandlerTags := map[string]any{
		"_dd.code_origin.type":          "entry",
		"_dd.code_origin.frames.0.file": testHandlersFile,
		"_dd.code_origin.frames.0.line": "26",
		// TODO(rarguelloF): unsure if this is the desirable behavior.
		"_dd.code_origin.frames.0.type":   "github.com/DataDog/dd-trace-go/contrib/net/http/v2.inlineHandler",
		"_dd.code_origin.frames.0.method": "func1",
	}
	wantMethodAsValueHandlerTags := map[string]any{
		"_dd.code_origin.type": "entry",
		// TODO(rarguelloF): not sure if there is anything we can do about this case
		"_dd.code_origin.frames.0.file": "<autogenerated>",
		"_dd.code_origin.frames.0.line": "1",
	}

	testCases := []struct {
		name            string
		disabled        bool
		getHandler      func() http.Handler
		skipWrapHandler bool
		wantTags        map[string]any
	}{
		{
			name:     "disabled",
			disabled: true,
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: map[string]any{},
		},
		{
			name: "HandlerFunc",
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: wantFuncHandlerTags,
		},
		{
			// in this test case we just run WrapHandler on the entire router, so it will point to ServeHTTP method
			// in the standard library.
			name: "http.NewServeMux",
			getHandler: func() http.Handler {
				mux := http.NewServeMux()
				mux.HandleFunc("/", testHandler)
				return mux
			},
			wantTags: wantStdlibMuxTags,
		},
		{
			// in this test case, because we are using our own httptrace.NewServeMux function, we should be able to
			// extract the actual handler code, and not the global router ServeHTTP method like in the previous case.
			name: "httptrace.NewServeMux",
			getHandler: func() http.Handler {
				tracedMux := NewServeMux(WithService("code-origins"))
				tracedMux.HandleFunc("/", testHandler)
				return tracedMux
			},
			skipWrapHandler: true, // we are already returning a traced handler, so skip the wrapping step from the test.
			wantTags:        wantFuncHandlerTags,
		},
		{
			name: "CustomHandler",
			getHandler: func() http.Handler {
				return &CustomHandler{}
			},
			wantTags: wantTypeHandlerTags,
		},
		{
			name:       "InlineHandlerFunc",
			getHandler: inlineHandler,
			wantTags:   wantInlineHandlerTags,
		},
		{
			name: "DefaultServeMux",
			getHandler: func() http.Handler {
				http.HandleFunc("/", testHandler)
				return http.DefaultServeMux
			},
			wantTags: wantStdlibMuxTags,
		},
		{
			name: "MethodValueHandler",
			getHandler: func() http.Handler {
				ch := &CustomHandler{}
				return http.HandlerFunc(ch.ServeHTTP)
			},
			wantTags: wantMethodAsValueHandlerTags,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mt := mocktracer.Start()
			defer mt.Stop()

			t.Setenv("DD_CODE_ORIGIN_FOR_SPANS_ENABLED", strconv.FormatBool(!tc.disabled))
			httptrace.ResetCfg()

			var h http.Handler
			if !tc.skipWrapHandler {
				h = WrapHandler(tc.getHandler(), "code-origins", "GET /")
			} else {
				h = tc.getHandler()
			}

			url := "/"
			r := httptest.NewRequest("GET", url, nil)
			w := httptest.NewRecorder()

			h.ServeHTTP(w, r)

			spans := mt.FinishedSpans()
			require.Len(t, spans, 1)
			s0 := spans[0]
			require.Equal(t, "http.request", s0.OperationName())
			require.Equal(t, "code-origins", s0.Tag(ext.ServiceName))
			require.Equal(t, "GET /", s0.Tag(ext.ResourceName))

			gotTags := make(map[string]any)
			for tag, value := range s0.Tags() {
				if strings.HasPrefix(tag, "_dd.code_origin") {
					gotTags[tag] = value
				}
			}
			assert.Equal(t, tc.wantTags, gotTags, "_dd.code_origin tags mismatch")
		})
	}
}

func TestCodeOriginForSpansStackTrace(t *testing.T) {
	t.Setenv("_DD_TEST_CODE_ORIGINS_STACK_TRACE", "true")

	_, filename, _, ok := runtime.Caller(0)
	require.True(t, ok)
	thisFile, err := filepath.Abs(filename)
	require.NoError(t, err)
	testHandlersFile := filepath.Join(filepath.Dir(thisFile), "code_origin_handlers_test.go")

	wantFuncHandlerTags := map[string]any{
		"_dd.code_origin.type":            "entry",
		"_dd.code_origin.frames.0.file":   testHandlersFile,
		"_dd.code_origin.frames.0.line":   "14", // should be line 13
		"_dd.code_origin.frames.0.method": "github.com/DataDog/dd-trace-go/contrib/net/http/v2.testHandler",
	}
	wantTypeHandlerTags := map[string]any{
		"_dd.code_origin.type":            "entry",
		"_dd.code_origin.frames.0.file":   testHandlersFile,
		"_dd.code_origin.frames.0.line":   "21", // should be line 20
		"_dd.code_origin.frames.0.type":   "github.com/DataDog/dd-trace-go/contrib/net/http/v2.*CustomHandler",
		"_dd.code_origin.frames.0.method": "ServeHTTP",
	}

	testCases := []struct {
		name            string
		disabled        bool
		getHandler      func() http.Handler
		skipWrapHandler bool
		wantTags        map[string]any
	}{
		{
			name:     "disabled",
			disabled: true,
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: map[string]any{},
		},
		{
			name: "HandlerFunc",
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: wantFuncHandlerTags,
		},
		{
			name: "http.NewServeMux",
			getHandler: func() http.Handler {
				mux := http.NewServeMux()
				mux.HandleFunc("/", testHandler)
				return mux
			},
			wantTags: wantFuncHandlerTags,
		},
		{
			name: "httptrace.NewServeMux",
			getHandler: func() http.Handler {
				tracedMux := NewServeMux(WithService("code-origins"))
				tracedMux.HandleFunc("/", testHandler)
				return tracedMux
			},
			skipWrapHandler: true, // we are already returning a traced handler, so skip the wrapping step from the test.
			wantTags:        wantFuncHandlerTags,
		},
		{
			name: "CustomHandler",
			getHandler: func() http.Handler {
				return &CustomHandler{}
			},
			wantTags: wantTypeHandlerTags,
		},
		{
			name:       "InlineHandlerFunc",
			getHandler: inlineHandler,
			wantTags:   wantFuncHandlerTags,
		},
		{
			name: "DefaultServeMux",
			getHandler: func() http.Handler {
				http.HandleFunc("/", testHandler)
				return http.DefaultServeMux
			},
			wantTags: wantFuncHandlerTags,
		},
		{
			name: "MethodValueHandler",
			getHandler: func() http.Handler {
				ch := &CustomHandler{}
				return http.HandlerFunc(ch.ServeHTTP)
			},
			wantTags: wantTypeHandlerTags,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mt := mocktracer.Start()
			defer mt.Stop()

			t.Setenv("DD_CODE_ORIGIN_FOR_SPANS_ENABLED", strconv.FormatBool(!tc.disabled))
			httptrace.ResetCfg()

			var h http.Handler
			if !tc.skipWrapHandler {
				h = WrapHandler(tc.getHandler(), "code-origins", "GET /")
			} else {
				h = tc.getHandler()
			}

			url := "/"
			r := httptest.NewRequest("GET", url, nil)
			w := httptest.NewRecorder()

			h.ServeHTTP(w, r)

			spans := mt.FinishedSpans()
			require.Len(t, spans, 1)
			s0 := spans[0]
			require.Equal(t, "http.request", s0.OperationName())
			require.Equal(t, "code-origins", s0.Tag(ext.ServiceName))
			require.Equal(t, "GET /", s0.Tag(ext.ResourceName))

			gotTags := make(map[string]any)
			extraFrameTags := make(map[string]any)
			for tag, value := range s0.Tags() {
				if strings.HasPrefix(tag, "_dd.code_origin") {
					if tag == "_dd.code_origin.type" || strings.HasPrefix(tag, "_dd.code_origin.frames.0") {
						gotTags[tag] = value
					} else {
						extraFrameTags[tag] = value
					}
				}
			}
			assert.Equal(t, tc.wantTags, gotTags, "_dd.code_origin tags mismatch")

			if !tc.disabled {
				assert.NotEmpty(t, extraFrameTags, "there should be at least 1 extra frame tag")
				t.Logf("extraFrameTags: %v\n", extraFrameTags)
			} else {
				assert.Empty(t, extraFrameTags)
			}
		})
	}
}

func serveMuxFileLine(t *testing.T) (file string, line string) {
	t.Helper()
	typ := reflect.TypeOf(&http.ServeMux{})
	method, ok := typ.MethodByName("ServeHTTP")
	require.True(t, ok)

	fn := runtime.FuncForPC(method.Func.Pointer())
	require.NotNil(t, fn)

	f, ln := fn.FileLine(method.Func.Pointer())
	return f, strconv.Itoa(ln)
}
