// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

package http

import (
	"net/http"
	"net/http/httptest"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"testing"

	"github.com/DataDog/dd-trace-go/v2/ddtrace/ext"
	"github.com/DataDog/dd-trace-go/v2/ddtrace/mocktracer"
	"github.com/DataDog/dd-trace-go/v2/instrumentation/httptrace"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCodeOriginForSpans(t *testing.T) {
	_, filename, _, ok := runtime.Caller(0)
	require.True(t, ok)
	testFilePath, err := filepath.Abs(filename)
	require.NoError(t, err)
	dir := filepath.Dir(testFilePath)
	testHandlersFile := filepath.Join(dir, "code_origin_handlers_test.go")

	const (
		funcHandlerLine       = "13"
		customTypeHandlerLine = "20"
	)

	muxFile, muxLine := serveMuxFileLine(t)

	testCases := []struct {
		name       string
		disabled   bool
		getHandler func() http.Handler
		wantTags   map[string]any
	}{
		{
			name:     "disabled",
			disabled: true,
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: map[string]any{},
		},
		{
			name: "HandlerFunc",
			getHandler: func() http.Handler {
				return http.HandlerFunc(testHandler)
			},
			wantTags: map[string]any{
				"_dd.code_origin.type":          "entry",
				"_dd.code_origin.frames.0.file": testHandlersFile,
				"_dd.code_origin.frames.0.line": funcHandlerLine,
			},
		},
		{
			name: "NewServeMux",
			getHandler: func() http.Handler {
				mux := http.NewServeMux()
				mux.HandleFunc("/", testHandler)
				return mux
			},
			wantTags: map[string]any{
				"_dd.code_origin.type":          "entry",
				"_dd.code_origin.frames.0.file": muxFile,
				"_dd.code_origin.frames.0.line": muxLine,
			},
		},
		{
			name: "CustomHandler",
			getHandler: func() http.Handler {
				return &CustomHandler{}
			},
			wantTags: map[string]any{
				"_dd.code_origin.type":          "entry",
				"_dd.code_origin.frames.0.file": testHandlersFile,
				"_dd.code_origin.frames.0.line": customTypeHandlerLine,
			},
		},
		{
			name: "InlineHandlerFunc",
			getHandler: func() http.Handler {
				return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					testHandler(w, r)
				})
			},
			wantTags: map[string]any{
				"_dd.code_origin.type":          "entry",
				"_dd.code_origin.frames.0.file": testFilePath,
				"_dd.code_origin.frames.0.line": "93",
			},
		},
		{
			name: "DefaultServeMux",
			getHandler: func() http.Handler {
				http.HandleFunc("/", testHandler)
				return http.DefaultServeMux
			},
			wantTags: map[string]any{
				"_dd.code_origin.type":          "entry",
				"_dd.code_origin.frames.0.file": muxFile,
				"_dd.code_origin.frames.0.line": muxLine,
			},
		},
		{
			name: "MethodValueHandler",
			getHandler: func() http.Handler {
				ch := &CustomHandler{}
				return http.HandlerFunc(ch.ServeHTTP)
			},
			wantTags: map[string]any{
				"_dd.code_origin.type": "entry",
				// not sure if there is anything we can do about this case
				"_dd.code_origin.frames.0.file": "<autogenerated>",
				"_dd.code_origin.frames.0.line": "1",
			},
		},
	}

	t.Run("runtime.FuncForPC", func(t *testing.T) {
		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				mt := mocktracer.Start()
				defer mt.Stop()

				t.Setenv("DD_CODE_ORIGIN_FOR_SPANS_ENABLED", strconv.FormatBool(!tc.disabled))
				httptrace.ResetCfg()

				h := WrapHandler(tc.getHandler(), "code-origins", "testHandler")
				url := "/"
				r := httptest.NewRequest("GET", url, nil)
				w := httptest.NewRecorder()
				// This is the only "user-code" frame that runtime.Callers is able to capture
				h.ServeHTTP(w, r)

				spans := mt.FinishedSpans()
				require.Len(t, spans, 1)
				s0 := spans[0]
				require.Equal(t, "http.request", s0.OperationName())
				require.Equal(t, "code-origins", s0.Tag(ext.ServiceName))
				require.Equal(t, "testHandler", s0.Tag(ext.ResourceName))

				gotTags := make(map[string]any)
				for tag, value := range s0.Tags() {
					if strings.HasPrefix(tag, "_dd.code_origin") {
						gotTags[tag] = value
					}
				}
				assert.Equal(t, tc.wantTags, gotTags, "_dd.code_origin tags mismatch")
			})
		}
	})

	t.Run("runtime.Callers", func(t *testing.T) {
		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				mt := mocktracer.Start()
				defer mt.Stop()

				t.Setenv("_DD_TEST_CODE_ORIGINS_RUNTIME_CALLERS", "1")
				t.Setenv("DD_CODE_ORIGIN_FOR_SPANS_ENABLED", strconv.FormatBool(!tc.disabled))
				httptrace.ResetCfg()

				h := WrapHandler(tc.getHandler(), "code-origins", "testHandler")
				url := "/"
				r := httptest.NewRequest("GET", url, nil)
				w := httptest.NewRecorder()
				// This is the only "user-code" frame that runtime.Callers is able to capture
				h.ServeHTTP(w, r)

				spans := mt.FinishedSpans()
				require.Len(t, spans, 1)
				s0 := spans[0]
				require.Equal(t, "http.request", s0.OperationName())
				require.Equal(t, "code-origins", s0.Tag(ext.ServiceName))
				require.Equal(t, "testHandler", s0.Tag(ext.ResourceName))

				gotTags := make(map[string]any)
				for tag, value := range s0.Tags() {
					if strings.HasPrefix(tag, "_dd.code_origin") {
						gotTags[tag] = value
					}
				}
				assert.Equal(t, tc.wantTags, gotTags, "_dd.code_origin tags mismatch")
			})
		}
	})
}

func serveMuxFileLine(t *testing.T) (file string, line string) {
	t.Helper()
	typ := reflect.TypeOf(&http.ServeMux{})
	method, ok := typ.MethodByName("ServeHTTP")
	require.True(t, ok)

	fn := runtime.FuncForPC(method.Func.Pointer())
	require.NotNil(t, fn)

	f, ln := fn.FileLine(method.Func.Pointer())
	return f, strconv.Itoa(ln)
}
