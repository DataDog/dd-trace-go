package codegen

import (
	"bytes"
	"fmt"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/gopackages"
	"github.com/dave/dst/dstutil"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"path/filepath"
)

const (
	commentStartEntrypoint = "//ddtrace:gen-entrypoint:start"
	commentEndEntrypoint   = "//ddtrace:gen-entrypoint:end"
	globalconfigImport     = "gopkg.in/DataDog/dd-trace-go.v1/internal/globalconfig"
)

func InjectComments() dst.NodeDecs {
	return dst.NodeDecs{
		Start: dst.Decorations{"\n", "// Code generated by process-contrib-entrypoints. DO NOT EDIT.", commentStartEntrypoint},
		End:   dst.Decorations{"\n", commentEndEntrypoint},
	}
}

func IntegrationDisabledCall() *dst.CallExpr {
	return &dst.CallExpr{
		Fun: &dst.Ident{
			Name: "IntegrationDisabled",
			Path: globalconfigImport,
		},
		Args: []dst.Expr{
			&dst.Ident{
				Name: "componentName",
			},
		},
	}
}

type UpdateNodeFunc func(cur *dstutil.Cursor) (changed bool, cont bool)

func (u UpdateNodeFunc) Chain(f UpdateNodeFunc) UpdateNodeFunc {
	if u == nil {
		return f
	}
	return func(cur *dstutil.Cursor) (bool, bool) {
		ch1, cont1 := u(cur)
		ch2, cont2 := f(cur)
		return ch1 || ch2, cont1 || cont2
	}
}

func UpdateFile(fPath string, fn UpdateNodeFunc) error {
	//content, err := os.ReadFile(fPath)
	//if err != nil {
	//	return err
	//}

	fName := filepath.Base(fPath)
	dirPath := filepath.Dir(fPath)
	pkgs, err := decorator.Load(&packages.Config{Dir: dirPath, Mode: packages.LoadSyntax})
	if err != nil {
		return err
	}

	if len(pkgs) == 0 || len(pkgs) > 1 {
		return fmt.Errorf("expected exactly 1 package, got: %d", len(pkgs))
	}
	pkg := pkgs[0]

	var f *dst.File
	for i, pkgFile := range pkg.GoFiles {
		if filepath.Base(pkgFile) == fName {
			f = pkg.Syntax[i]
			break
		}
	}
	if f == nil {
		return nil
		// return fmt.Errorf("file not found: %s", fPath)
	}

	//fset := token.NewFileSet()
	//astFile, err := parser.ParseFile(fset, fPath, content, parser.ParseComments)
	//if err != nil {
	//	return fmt.Errorf("error parsing content in %s: %w", fPath, err)
	//}

	//dec := decorator.NewDecoratorWithImports(fset, fPath, goast.New())
	//f, err := dec.DecorateFile(astFile)
	//if err != nil {
	//	return fmt.Errorf("error decorating file %s: %v", fPath, err)
	//}

	updateFile := false
	dstutil.Apply(f, func(cur *dstutil.Cursor) bool {
		changed, cont := fn(cur)
		if changed {
			updateFile = changed
		}
		return cont
	}, nil)

	if updateFile {
		restorer := decorator.NewRestorerWithImports(fPath, gopackages.New(dirPath))
		var buf bytes.Buffer
		if err := restorer.Fprint(&buf, f); err != nil {
			log.Fatal(err)
		}
		return os.WriteFile(fPath, buf.Bytes(), 0755)
	}

	return nil
}
