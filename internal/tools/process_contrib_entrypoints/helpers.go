package main

import (
	"bytes"
	"fmt"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/goast"
	"github.com/dave/dst/decorator/resolver/guess"
	"github.com/dave/dst/dstutil"
	"go/parser"
	"go/token"
	"log"
	"os"
	"slices"
	"strconv"
	"strings"
	"unicode"
)

const (
	commentStartEntrypoint = "//ddtrace:gen-entrypoint:start"
	commentEndEntrypoint   = "//ddtrace:gen-entrypoint:end"
	globalconfigImport     = "gopkg.in/DataDog/dd-trace-go.v1/internal/globalconfig"
)

var (
	injectComments = dst.NodeDecs{
		Start: dst.Decorations{"\n", "// Code generated by process-contrib-entrypoints. DO NOT EDIT.", commentStartEntrypoint},
		End:   dst.Decorations{"\n", commentEndEntrypoint},
	}
)

type variable struct {
	Name string
	Type string
}

func (v variable) String() string {
	res := ""
	if v.Name != "" {
		res += v.Name + " "
	}
	res += v.Type
	return res
}

func (v variable) SplitPackageType() (string, string, bool) {
	lastDot := strings.LastIndex(v.Type, ".")

	if lastDot == -1 {
		return "", "", false
	}

	pkg := v.Type[:lastDot]
	typeName := v.Type[lastDot+1:]

	return strings.TrimPrefix(pkg, "*"), typeName, true
}

type functionSignature struct {
	Name      string
	Arguments []variable
	Returns   []variable
}

func (f functionSignature) String() string {
	res := "func"
	if f.Name != "" {
		res = res + " " + f.Name + "("
	}
	var args []string
	for _, arg := range f.Arguments {
		args = append(args, arg.String())
	}
	res = res + strings.Join(args, ", ") + ")"

	var rets []string
	for _, ret := range f.Returns {
		rets = append(rets, ret.String())
	}
	if len(rets) == 0 {
		return res
	}
	if len(rets) == 1 {
		return res + " " + rets[0]
	}
	return res + fmt.Sprintf(" (%s)", strings.Join(rets, ", "))
}

func getFunctionSignature[T *dst.FuncDecl | *dst.FuncType](fn T) functionSignature {
	var (
		name    string
		params  *dst.FieldList
		results *dst.FieldList
	)
	switch t := any(fn).(type) {
	case *dst.FuncDecl:
		name = t.Name.Name
		params = t.Type.Params
		results = t.Type.Results

	case *dst.FuncType:
		name = "" // anonymous function don't have a name
		params = t.Params
		results = t.Results
	}

	var (
		args []variable
		rets []variable
	)
	if params != nil {
		args = parseFields(params.List)
	}
	if results != nil {
		rets = parseFields(results.List)
	}
	return functionSignature{
		Name:      name,
		Arguments: args,
		Returns:   rets,
	}
}

func parseFields(fields []*dst.Field) []variable {
	vars := make([]variable, len(fields))
	for i, ret := range fields {
		name := ""
		if len(ret.Names) > 0 {
			name = ret.Names[0].Name
		}
		vars[i] = variable{
			Name: name,
			Type: getType(ret.Type),
		}
	}
	return vars
}

func getType(varType dst.Expr) string {
	switch t := varType.(type) {
	case *dst.SelectorExpr:
		x, ok := t.X.(*dst.Ident)
		if !ok {
			panic(fmt.Errorf("don't know how to handle *dst.SelectorExpr.X, got type: %T", t.X))
		}
		typePkg := x.Name
		typeName := t.Sel.Name
		if typePkg != "" {
			return typePkg + "." + typeName
		}
		return typeName

	case *dst.Ellipsis:
		name := ""
		switch elt := t.Elt.(type) {
		case *dst.Ident:
			name = elt.Name
		default:
			name = getType(elt)
		}
		return "[]" + name

	case *dst.StarExpr:
		return "*" + getType(t.X)

	case *dst.Ident:
		if t.Obj != nil {
			if assign, ok := t.Obj.Decl.(*dst.AssignStmt); ok {
				if len(assign.Rhs) > 0 {
					return getType(assign.Rhs[0])
				}
			}
		}
		name := t.Name
		if t.Path != "" {
			name = t.Path + "." + name
		}
		return name

	case *dst.FuncType:
		return getFunctionSignature(t).String()

	case *dst.InterfaceType:
		return "interface{}"

	case *dst.ArrayType:
		return "[]" + getType(t.Elt)

	case *dst.MapType:
		return fmt.Sprintf("map[%s]%s", getType(t.Key), getType(t.Value))

	case *dst.UnaryExpr:
		name := ""
		if t.Op == token.AND {
			name = "*"
		}
		return name + getType(t.X)

	case *dst.CompositeLit:
		return getType(t.Type)
	}

	panic(fmt.Errorf("don't know how to handle dst.Expr, got type: %T", varType))
}

func removePreviousInjectedCode(fn *dst.FuncDecl) {
	var keep []dst.Stmt
	for _, stmt := range fn.Body.List {
		decs := stmt.Decorations()
		if slices.Contains(decs.Start.All(), commentStartEntrypoint) {
			continue
		}
		var keepComments []string
		for _, dec := range decs.Start.All() {
			if dec == commentEndEntrypoint {
				continue
			}
			keepComments = append(keepComments, dec)
		}
		stmt.Decorations().Start.Replace(keepComments...)
		keep = append(keep, stmt)
	}
	fn.Body.List = keep
}

func addStructField(structType *dst.StructType, field *dst.Field) {
	structType.Fields.List = append(structType.Fields.List, field)
}

func removePreviousInjectStructFields(structType *dst.StructType, only []string) {
	var keep []*dst.Field

	if structType.Fields == nil {
		return
	}
	for _, f := range structType.Fields.List {
		if slices.Contains(only, fieldName(f)) && isInjectedField(f) {
			continue
		}
		keep = append(keep, f)
	}
	structType.Fields.List = keep
}

func fieldName(f *dst.Field) string {
	if len(f.Names) == 0 {
		return ""
	}
	return f.Names[0].Name
}

func isInjectedField(f *dst.Field) bool {
	decs := f.Decorations()
	return slices.Contains(decs.Start.All(), commentStartEntrypoint)
}

func integrationDisabledCallExpr() *dst.CallExpr {
	return &dst.CallExpr{
		Fun: &dst.Ident{
			Name: "IntegrationDisabled",
			Path: globalconfigImport,
		},
		Args: []dst.Expr{
			&dst.Ident{
				Name: "componentName",
			},
		},
	}
}

func earlyReturnStatement(cond dst.Expr, rets []string) *dst.BlockStmt {
	var results []dst.Expr
	for _, ret := range rets {
		results = append(results, &dst.Ident{Name: ret})
	}
	return &dst.BlockStmt{
		List: []dst.Stmt{
			&dst.IfStmt{
				Cond: cond,
				Body: &dst.BlockStmt{
					List: []dst.Stmt{
						&dst.ReturnStmt{
							Results: results,
						},
					},
				},
			},
		},
		Decs: dst.BlockStmtDecorations{
			NodeDecs: injectComments,
		},
	}
}

type updateNodeFunc func(cur *dstutil.Cursor) (changed bool, cont bool)

func loadAndModifyFile(fPath string, fn updateNodeFunc) error {
	content, err := os.ReadFile(fPath)
	if err != nil {
		return err
	}

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, fPath, content, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("error parsing content in %s: %w", fPath, err)
	}

	dec := decorator.NewDecoratorWithImports(fset, fPath, goast.New())
	f, err := dec.DecorateFile(astFile)
	if err != nil {
		return fmt.Errorf("error decorating file %s: %v", fPath, err)
	}

	updateFile := false
	dstutil.Apply(f, func(cur *dstutil.Cursor) bool {
		changed, cont := fn(cur)
		if changed {
			updateFile = changed
		}
		return cont
	}, nil)

	if updateFile {
		restorer := decorator.NewRestorerWithImports(fPath, guess.New())
		var buf bytes.Buffer
		if err := restorer.Fprint(&buf, f); err != nil {
			log.Fatal(err)
		}
		return os.WriteFile(fPath, buf.Bytes(), 0755)
	}

	return nil
}

func getUnusedIdentifier(fn *dst.FuncDecl, prefix string) string {
	tryName := prefix
	count := 1
	for isIdentifierUsed(fn, tryName) {
		tryName = prefix + strconv.Itoa(count)
		count++
	}
	return tryName
}

func isIdentifierUsed(fn *dst.FuncDecl, targetIdent string) bool {
	s := getFunctionSignature(fn)
	for _, arg := range s.Arguments {
		if arg.Name == targetIdent {
			return true
		}
	}
	for _, ret := range s.Returns {
		if ret.Name == targetIdent {
			return true
		}
	}
	for _, stmt := range fn.Body.List {
		if assign, ok := stmt.(*dst.AssignStmt); ok {
			for _, l := range assign.Lhs {
				if ident, ok := l.(*dst.Ident); ok {
					if ident.Name == targetIdent {
						return true
					}
				}
			}
		}
	}
	return false
}

func findPublicMethods(pkg *dst.Package, typeName string) map[string][]*dst.FuncDecl {
	res := make(map[string][]*dst.FuncDecl)
	for fPath, f := range pkg.Files {
		for _, decl := range f.Decls {
			if fn, ok := decl.(*dst.FuncDecl); ok {
				if !isPublicFunction(fn) {
					continue
				}
				if fn.Recv != nil && len(fn.Recv.List) > 0 {
					t := getType(fn.Recv.List[0].Type)
					if strings.TrimPrefix(t, "*") == strings.TrimPrefix(typeName, "*") {
						res[fPath] = append(res[fPath], fn)
					}
				}
			}
		}
	}
	return res
}

func isPublicFunction(fn *dst.FuncDecl) bool {
	return unicode.IsUpper(rune(fn.Name.Name[0]))
}
