package main

import (
	"fmt"
	"github.com/dave/dst"
)

type entrypointWrap struct{}

func (e entrypointWrap) Apply(fn *dst.FuncDecl, _ ...string) error {
	removePreviousInjectedCode(fn)
	s := getFunctionSignature(fn)

	newReturns := make([]string, len(s.Returns))
	for i, ret := range s.Returns {
		if ret.Type == "error" {
			newReturns[i] = "nil"
			continue
		}
		found := false
		for _, arg := range s.Arguments {
			if arg.Type == ret.Type {
				if arg.Name == "" {
					return fmt.Errorf("cannot return %s, argument does not have a name", arg.Type)
				}
				newReturns[i] = arg.Name
				found = true
				break
			}
		}
		if !found {
			return fmt.Errorf("could not found an argument with the same type as the return field %v (fn: %v)", ret, s)
		}
	}

	newLines := e.prependStmt(newReturns)
	fn.Body.List = append([]dst.Stmt{newLines}, fn.Body.List...)
	return nil
}

func (e *entrypointWrap) prependStmt(rets []string) *dst.BlockStmt {
	var results []dst.Expr
	for _, ret := range rets {
		results = append(results, &dst.Ident{Name: ret})
	}
	return &dst.BlockStmt{
		List: []dst.Stmt{
			&dst.IfStmt{
				Cond: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: "IntegrationDisabled",
						Path: "gopkg.in/DataDog/dd-trace-go.v1/internal/globalconfig",
					},
					Args: []dst.Expr{
						&dst.Ident{
							Name: "componentName",
						},
					},
				},
				Body: &dst.BlockStmt{
					List: []dst.Stmt{
						&dst.ReturnStmt{
							Results: results,
						},
					},
				},
			},
		},
		Decs: dst.BlockStmtDecorations{
			NodeDecs: dst.NodeDecs{
				Start: dst.Decorations{"\n", "// Code generated by process-contrib-entrypoints. DO NOT EDIT.", commentStartEntrypoint},
				End:   dst.Decorations{"\n", commentEndEntrypoint},
			},
		},
	}
}
